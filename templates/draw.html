<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Fabric.js Example with WebSocket</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.2.4/fabric.min.js"></script>
    <style>
        #canvas-container {
            border: 1px solid #ccc;
            margin: 20px 0;
        }
        button, input[type="file"] {
            margin-right: 10px;
            margin-bottom: 10px;
        }
    </style>
</head>
<body>
    <h1>Fabric.js Example with WebSocket</h1>
    <div>
        <button onclick="addText()">Add Text</button>
        <button onclick="addEmoji('üòä')">Add Emoji üòä</button>
        <button onclick="addEmoji('‚ù§Ô∏è')">Add Emoji ‚ù§Ô∏è</button>
        <input type="file" id="uploadImage" accept="image/*" />
        <button onclick="enableDrawing()">Enable Drawing</button>
        <button onclick="disableDrawing()">Disable Drawing</button>
        <button onclick="bringForward()">Bring Forward</button>
        <button onclick="sendBackward()">Send Backward</button>
        <button onclick="clearCanvas()">Clear Canvas</button>
    </div>
    <div id="canvas-container">
        <canvas id="fabricCanvas" width="800" height="600"></canvas>
    </div>
    <script>
        const canvas = new fabric.Canvas('fabricCanvas', {
            backgroundColor: 'white',
            isDrawingMode: false,
        });

        const socket = new WebSocket('ws://' + window.location.host + '/ws/canvas/');

        let isRemoteUpdate = false; // Flag to avoid update loops

        socket.onopen = function(event) {
            console.log('WebSocket connected');
        };

        socket.onmessage = function(event) {
            const data = JSON.parse(event.data);
            const action = data.action;
            const payload = data.payload;

            if (action === "update") {
                isRemoteUpdate = true; // Prevent sending this change back
                canvas.loadFromJSON(payload, () => {
                    canvas.renderAll();
                    isRemoteUpdate = false; // Reset the flag
                });
            }
        };

        socket.onerror = function(event) {
            console.error('WebSocket error:', event);
        };

        socket.onclose = function(event) {
            console.log('WebSocket closed:', event);
        };

        function sendCanvasUpdate(action, payload) {
            if (!isRemoteUpdate) {
                socket.send(JSON.stringify({
                    action: action,
                    payload: payload,
                }));
            }
        }

        function addText() {
            const text = new fabric.Textbox('Type here...', {
                left: 100,
                top: 100,
                fontSize: 20,
                width: 200,
                selectable: true,
                editable: true,
            });
            canvas.add(text);
            canvas.setActiveObject(text);
            sendCanvasUpdate('update', canvas.toJSON());
        }

        function addEmoji(emoji) {
            const text = new fabric.Text(emoji, {
                left: 100,
                top: 100,
                fontSize: 60,
                selectable: true,
            });
            canvas.add(text);
            sendCanvasUpdate('update', canvas.toJSON());
        }

        document.getElementById('uploadImage').addEventListener('change', function (e) {
            const reader = new FileReader();
            reader.onload = function (event) {
                fabric.Image.fromURL(event.target.result, function (img) {
                    img.scaleToWidth(200);
                    img.set({ left: 100, top: 100, selectable: true });
                    canvas.add(img);
                    sendCanvasUpdate('update', canvas.toJSON());
                });
            };
            reader.readAsDataURL(e.target.files[0]);
        });

        function enableDrawing() {
            canvas.isDrawingMode = true;
            canvas.freeDrawingBrush.width = 3;
            canvas.freeDrawingBrush.color = 'black';
        }

        function disableDrawing() {
            canvas.isDrawingMode = false;
        }

        function bringForward() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.bringForward(activeObject);
                sendCanvasUpdate('update', canvas.toJSON());
            } else {
                alert('Select an object to bring forward.');
            }
        }

        function sendBackward() {
            const activeObject = canvas.getActiveObject();
            if (activeObject) {
                canvas.sendBackwards(activeObject);
                sendCanvasUpdate('update', canvas.toJSON());
            } else {
                alert('Select an object to send backward.');
            }
        }

        function clearCanvas() {
            canvas.clear();
            canvas.backgroundColor = 'white';
            sendCanvasUpdate('update', canvas.toJSON());
        }

        canvas.on('object:added', () => sendCanvasUpdate('update', canvas.toJSON()));
        canvas.on('object:modified', () => sendCanvasUpdate('update', canvas.toJSON()));
        canvas.on('object:removed', () => sendCanvasUpdate('update', canvas.toJSON()));
    </script>
</body>
</html>
